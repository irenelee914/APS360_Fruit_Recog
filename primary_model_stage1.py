# -*- coding: utf-8 -*-
"""Copy of Primary Model_30_Classes_FINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LiyagbcOPad4ybLzyNG7ECz1aevJaLRx
"""

#mount googledrive
from google.colab import drive
drive.mount('/content/gdrive')

# Loading Fruit Images from Google Drive

import torch
import numpy as np
import time
import os
import torchvision
import torchvision.transforms as transforms
from torch.utils.data.sampler import SubsetRandomSampler
import matplotlib.pyplot as plt

# location on Google Drive
master_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/'

# Transform Settings - Do not use RandomResizedCrop
transform = transforms.Compose([transforms.Resize((224,224)),
                                transforms.RandomAffine((-60,60), translate=(0.2,0.2), scale=(0.6,1.2), shear=None, resample=False, fillcolor=(255,255,255)), 
                                transforms.ToTensor()])

#transform = transforms.Compose([transforms.Resize((224,224)),
#                                transforms.RandomAffine((0), translate=(0.3,0.5), scale=None, shear=None, resample=False, fillcolor=(0,0,0)), 
#                                transforms.ToTensor()])

#define training/test/validation directories
train_dir = os.path.join(master_path, 'Train/')
val_dir = os.path.join(master_path, 'Validation/')
test_dir = os.path.join(master_path, 'Test/')

# Load data from Google Drive
#dataset = torchvision.datasets.ImageFolder(master_path, transform=transform)
train_data = torchvision.datasets.ImageFolder(train_dir, transform=transform)
val_data = torchvision.datasets.ImageFolder(val_dir, transform=transform)
test_data = torchvision.datasets.ImageFolder(test_dir, transform=transform)

# Prepare Dataloader
batch_size = 32
num_workers = 1

# prepare data loaders
train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, 
                                           num_workers=num_workers, shuffle=True)
val_loader = torch.utils.data.DataLoader(val_data, batch_size=batch_size, 
                                          num_workers=num_workers, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, num_workers=num_workers, shuffle=True)


#prepare small dataset
# overFitTrain_dir = os.path.join(master_path, 'small_dataset/')
# small_data = torchvision.datasets.ImageFolder(overFitTrain_dir, transform=transform)
# smallData_loader = torch.utils.data.DataLoader(small_data, batch_size=batch_size, 
#                                           num_workers=num_workers, shuffle=True)


# Verification Step - obtain one batch of images
dataiter = iter(train_loader)
images, labels = dataiter.next()
images = images.numpy() # convert images to numpy for display

#classes = ['Apricot', 'Avocado', 'Orange', 'Papaya', 'Peach', 'Pear', 'Pomegranate', 'Raspberry', 'Strawberry', 'Walnut',
 #          'Apple_Crimson_Snow', 'Apple_Granny_Smith', 'Apple_Red_Delicious','Apple_Pink_Lady','Banana','Cherry','Cherry_Wax_Yellow','Cocos','Lemon','Tomato',
 #          'Dates','Lychee','Mandarine','Mango','Nectarine','Peach_Flat','Limes','Plum','Guava','Pear_Red',
 #          'Clementine','Pear_Abate','Pear_Forelle','Pear_Kaiser','Pear_Monster','Pear_Williams']


classes = ['Apple_Crimson_Snow', 'Apple_Granny_Smith','Apple_Pink_Lady', 'Apple_Red_Delicious','Apricot', 'Avocado','Banana', 
          'Clementine','Cocos', 'Guava','Lemon','Limes','Lychee','Mandarine', 'Mango', 'Nectarine',
          'Orange', 'Peach','Peach_Flat', 'Pear', 'Pear_Abate','Pear_Forelle','Pear_Kaiser','Pear_Monster','Pear_Red', 'Pear_Williams',
          'Plum','Pomegranate',  'Strawberry', 'Walnut']

# plot the images in the batch, along with the corresponding labels
fig = plt.figure(figsize=(25, 4))
for idx in np.arange(20):
    ax = fig.add_subplot(2, 20/2, idx+1, xticks=[], yticks=[])
    plt.imshow(np.transpose(images[idx], (1, 2, 0)))
    ax.set_title(classes[labels[idx]])

#import pretrained vgg16

import torchvision.models
vgg16  = torchvision.models.vgg16 (pretrained=True)

# location on Google Drive
trainFeature_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/Train_Features'
validFeature_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/Valid_Features'
testFeature_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/Test_Features'

# location on Google Drive
trainFeature_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/Train_Features'
validFeature_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/Valid_Features'
testFeature_path = '/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/Test_Features'

# Prepare Dataloader (requires code from 1.)
batch_size = 1 # save 1 file at a time, hence batch_size = 1
num_workers = 1

train_loader = torch.utils.data.DataLoader(train_data, batch_size=batch_size, 
                                            num_workers=num_workers, shuffle=True)
val_loader = torch.utils.data.DataLoader(val_data, batch_size=batch_size, 
                                           num_workers=num_workers, shuffle=True)
test_loader = torch.utils.data.DataLoader(test_data, batch_size=batch_size, 
                                            num_workers=num_workers, shuffle=True)

classes = ['Apple_Crimson_Snow', 'Apple_Granny_Smith','Apple_Pink_Lady', 'Apple_Red_Delicious','Apricot', 'Avocado','Banana', 
          'Clementine','Cocos', 'Guava','Lemon','Limes','Lychee','Mandarine', 'Mango', 'Nectarine',
          'Orange', 'Peach','Peach_Flat', 'Pear', 'Pear_Abate','Pear_Forelle','Pear_Kaiser','Pear_Monster','Pear_Red', 'Pear_Williams',
          'Plum','Pomegranate',  'Strawberry', 'Walnut']


# save features to folder as tensors
n = 0
for img, label in train_loader:
  features = vgg16.features(img)
  features_tensor = torch.from_numpy(features.detach().numpy())

  folder_name = trainFeature_path + '/' + str(classes[label])
  if not os.path.isdir(folder_name):
    os.mkdir(folder_name)
  torch.save(features_tensor.squeeze(0), folder_name + '/' + str(n) + '.tensor')
  n += 1

for img, label in val_loader:
  features = vgg16.features(img)
  features_tensor = torch.from_numpy(features.detach().numpy())

  folder_name = validFeature_path + '/' + str(classes[label])
  if not os.path.isdir(folder_name):
    os.mkdir(folder_name)
  torch.save(features_tensor.squeeze(0), folder_name + '/' + str(n) + '.tensor')
  n += 1

for img, label in test_loader:
  features = vgg16.features(img)
  features_tensor = torch.from_numpy(features.detach().numpy())

  folder_name = testFeature_path + '/' + str(classes[label])
  if not os.path.isdir(folder_name):
    os.mkdir(folder_name)
  torch.save(features_tensor.squeeze(0), folder_name + '/' + str(n) + '.tensor')
  n += 1

# Load Tensor Files (features) from folder

#load features
# location on Google Drive

train_feature_dataset = torchvision.datasets.DatasetFolder(trainFeature_path, loader=torch.load, extensions=('.tensor'))
valid_feature_dataset = torchvision.datasets.DatasetFolder(validFeature_path, loader=torch.load, extensions=('.tensor'))
test_feature_dataset = torchvision.datasets.DatasetFolder(testFeature_path, loader=torch.load, extensions=('.tensor'))

# Prepare Dataloader
batch_size = 32
num_workers = 1
train_feature_loader = torch.utils.data.DataLoader(train_feature_dataset, batch_size=batch_size, 
                                           num_workers=num_workers, shuffle=True)
valid_feature_loader = torch.utils.data.DataLoader(valid_feature_dataset, batch_size=batch_size, 
                                          num_workers=num_workers, shuffle=True)
test_feature_loader = torch.utils.data.DataLoader(test_feature_dataset, batch_size=batch_size, 
                                           num_workers=num_workers, shuffle=True)

# # Verification Step - obtain one batch of features
train_dataiter = iter(train_feature_loader)
features, labels = train_dataiter.next()
print(features.shape)
print(labels.shape)

import torch.nn as nn
  import torch.optim as optim
  import torch.nn.functional as F

class TransferNN(nn.Module):
    def __init__(self):
        super(TransferNN, self).__init__()
        self.fc1 = nn.Linear(512 * 7 * 7, 40)
        self.fc2 = nn.Linear(40, 30)

    def forward(self, x):
        x = x.view(-1, 512 * 7 * 7) #flatten feature data
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

import torch.nn as nn
  import torch.optim as optim
  import torch.nn.functional as F

class TransferNN2(nn.Module):
    def __init__(self):
        super(TransferNN2, self).__init__()
        self.fc1 = nn.Linear(512 * 7 * 7, 80)
        self.fc2 = nn.Linear(80, 30)

    def forward(self, x):
        x = x.view(-1, 512 * 7 * 7) #flatten feature data
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

import torch.nn as nn
  import torch.optim as optim
  import torch.nn.functional as F

class TransferNN3(nn.Module):
    def __init__(self):
        super(TransferNN3, self).__init__()
        self.fc1 = nn.Linear(512 * 7 * 7, 120)
        self.fc2 = nn.Linear(120, 80)
        self.fc3 = nn.Linear(80,30)

    def forward(self, x):
        x = x.view(-1, 512 * 7 * 7) #flatten feature data
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

import torch.nn as nn
  import torch.optim as optim
  import torch.nn.functional as F

class TransferNN4(nn.Module):
    def __init__(self):
        super(TransferNN4, self).__init__()
        self.fc1 = nn.Linear(512 * 7 * 7, 40)
        self.fc2 = nn.Linear(40, 30)

    def forward(self, x):
        x = x.view(-1, 512 * 7 * 7) #flatten feature data
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

def plotAccuracy(train_acc, val_acc):
  plt.title("Train vs Validation Acc")
  n = len(train_acc) # number of epochs
  plt.plot(range(1,n+1), train_acc, label="Train")
  plt.plot(range(1,n+1), val_acc, label="Validation")
  plt.xlabel("Epoch")
  plt.ylabel("Accuracy")
  plt.legend(loc='best')
  plt.show()

def get_accuracy_vgg16(model, data_loader):
    correct = 0
    total = 0
    for imgs, labels in data_loader:
        

        #if use_cuda and torch.cuda.is_available():
        #  imgs = imgs.cuda()
        #  labels = labels.cuda()

        output = model(imgs)
        #select index with maximum prediction score
        #pred = F.softmax(output)
        pred = output.max(1, keepdim=True)[1] 
        correct += pred.eq(labels.view_as(pred)).sum().item()
        total += imgs.shape[0]
    return correct / total

# Training
def get_model_name(batch_size, learning_rate, epoch):
    """ Generate a name for the model consisting of all the hyperparameter values

    Args:
        config: Configuration object containing the hyperparameters
    Returns:
        path: A string with the hyperparameter name and value concatenated
    """


    ######Change path#########
    path = "/content/gdrive/My Drive/Colab Notebooks/Fruit_Project/run25/bs{0}_lr{1}_epoch{2}".format(
                                                   batch_size,
                                                   learning_rate,
                                                   epoch)
    return path

def train_vgg16(model, train_loader, val_loader, batch_size=27, num_epochs=1, learn_rate = 0.001):

    torch.manual_seed(1000)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=learn_rate)

    train_acc, val_acc = [], []

    # training
    print ("Training Started...")
    n = 0 # the number of iterations
    for epoch in range(num_epochs):
        for imgs, labels in iter(train_loader):

            #if use_cuda and torch.cuda.is_available():
            #  imgs = imgs.cuda()
            #  labels = labels.cuda()

            out = model(imgs)             # forward pass
            loss = criterion(out, labels) # compute the total loss
            loss.backward()               # backward pass (compute parameter updates)
            optimizer.step()              # make the updates for each parameter
            optimizer.zero_grad()         # a clean up step for PyTorch
            n += 1
        
        # track accuracy
        train_acc.append(get_accuracy_vgg16(model, train_loader))
        val_acc.append(get_accuracy_vgg16(model, val_loader))
        print(epoch, train_acc[-1], val_acc[-1])

        
        model_path = get_model_name(batch_size, learn_rate, epoch)
        torch.save(model.state_dict(),model_path)    
    return train_acc, val_acc

#################RUN7#########################################################
TransferNet7 = TransferNN3()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet7, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=30, learn_rate = 0.01)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet7, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN8#########################################################
TransferNet8 = TransferNN3()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet8, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=50, learn_rate = 0.005)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet8, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN9#########################################################
TransferNet9 = TransferNN3()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet9, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=20, learn_rate = 0.003)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet9, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN9#########################################################
TransferNet10 = TransferNN3()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet10, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=20, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet10, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN9#########################################################
TransferNet11 = TransferNN2()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet11, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=20, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet11, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN9#########################################################
TransferNet12 = TransferNN2()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet12, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=20, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet12, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN9#########################################################
TransferNet13 = TransferNN()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet13, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=20, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

#################RUN9#########################################################
TransferNet14 = TransferNN()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet14, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=10, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

#################RUN9#########################################################
TransferNet24 = TransferNN4()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet24, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=10, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet24, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

#################RUN9#########################################################
TransferNet26 = TransferNN2()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet26, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=10, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

#################RUN9#########################################################
TransferNet30 = TransferNN4()
#use_cuda = True

#if use_cuda and torch.cuda.is_available():
#  TransferNet.cuda()
#  print('CUDA is available!  Training on GPU ...')
#else:
#  print('CUDA is not available.  Training on CPU ...')

train_acc, val_acc = train_vgg16(TransferNet30, train_feature_loader, valid_feature_loader,batch_size=32, num_epochs=10, learn_rate = 0.001)
plotAccuracy(train_acc, val_acc)

test_accuracy = get_accuracy_vgg16(TransferNet30, test_feature_loader)

print("Test Accuracy: ", test_accuracy)

def get_accuracy_vgg16_modified(model, data_loader,fruit_label):
    correct = 0
    total = 0
    for imgs, labels in data_loader:
        
        if labels != fruit_label:
          continue
        #if use_cuda and torch.cuda.is_available():
        #  imgs = imgs.cuda()
        #  labels = labels.cuda()

        output = model(imgs)
        pred = output.max(1, keepdim=True)[1] 
        print(pred)
        correct += pred.eq(labels.view_as(pred)).sum().item()
        total += imgs.shape[0]
    print(total)
    return correct / total

test_feature_loader = torch.utils.data.DataLoader(test_feature_dataset, batch_size=1, 
                                           num_workers=num_workers, shuffle=True)

#['Apricot', 'Avocado', 'Orange', 'Papaya', 'Peach', 'Pear', 'Pomegranate', 'Raspberry', 'Strawberry', 'Walnut']



['Apple_Crimson_Snow', 'Apple_Granny_Smith','Apple_Pink_Lady', 'Apple_Red_Delicious','Apricot', 'Avocado','Banana', 
'Clementine','Cocos', 'Guava','Lemon','Limes','Lychee','Mandarine', 'Mango', 'Nectarine',
'Orange', 'Peach','Peach_Flat', 'Pear', 'Pear_Abate','Pear_Forelle','Pear_Kaiser','Pear_Monster','Pear_Red', 'Pear_Williams',
'Plum','Pomegranate',  'Strawberry', 'Walnut']


test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 0)
print("Test Accuracy of Apple_Crimson_Snow: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 1)
print("Test Accuracy of Apple_Granny_Smith: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 2)
print("Test Accuracy of Apple_Pink_Lady: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 3)
print("Test Accuracy of Apple_Red_Delicious: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 4)
print("Test Accuracy of Apricot: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 5)
print("Test Accuracy of Avocado: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 6)
print("Test Accuracy of Banana: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 7)
print("Test Accuracy Clementine: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 8)
print("Test Accuracy of Cocos: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 9)
print("Test Accuracy of Guava: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 10)
print("Test Accuracy of Lemon: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 11)
print("Test Accuracy of Limes: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 12)
print("Test Accuracy of Lychee: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 13)
print("Test Accuracy of Mandarine: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 14)
print("Test Accuracy of Mango: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 15)
print("Test Accuracy of Nectarine: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 16)
print("Test Accuracy of Orange: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 17)
print("Test Accuracy Peach: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 18)
print("Test Accuracy of Peach_Flat: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 19)
print("Test Accuracy of Pear: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 20)
print("Test Accuracy of Pear_Abate: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 21)
print("Test Accuracy of Pear_Forelle: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 22)
print("Test Accuracy of Pear_Kaiser: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 23)
print("Test Accuracy of Pear_Monster: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 24)
print("Test Accuracy of Pear_Red: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 25)
print("Test Accuracy of Pear_Williams: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 26)
print("Test Accuracy of Plum: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 27)
print("Test Accuracy Pomegranate: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 28)
print("Test Accuracy of Strawberry: ", test_accuracy)

test_accuracy = get_accuracy_vgg16_modified(TransferNet30, test_feature_loader, 29)
print("Test Accuracy of Walnut: ", test_accuracy)
